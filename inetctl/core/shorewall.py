from pathlib import Path
from typing import Dict, List
from itertools import permutations
import re

from inetctl.core.netplan import get_vlan_subnets

def apply_shorewall_config(file_path_str: str, new_content: str, managed_block_name: str = None) -> bool:
    """
    Safely writes new content to a Shorewall configuration file.
    """
    file_path = Path(file_path_str)
    if not file_path.parent.exists():
        print(f"ERROR: Cannot write to {file_path_str}, parent directory does not exist.")
        return False

    file_path.touch(mode=0o640, exist_ok=True) 
    current_content = file_path.read_text()
    
    if not managed_block_name:
        if current_content.strip() == new_content.strip():
            return False
        else:
            file_path.write_text(new_content)
            return True

    start_marker = f"# --- INETCTL MANAGED {managed_block_name} START ---"
    end_marker = f"# --- INETCTL MANAGED {managed_block_name} END ---"
    managed_content_with_markers = f"{start_marker}\n{new_content.strip()}\n{end_marker}\n"
    block_pattern = re.compile(f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL)
    
    if block_pattern.search(current_content):
        updated_content = block_pattern.sub(managed_content_with_markers, current_content)
    else:
        updated_content = current_content.strip() + "\n\n" + managed_content_with_markers

    if current_content.strip() == updated_content.strip():
        return False
    else:
        file_path.write_text(updated_content)
        return True

def parse_shorewall_interfaces() -> Dict[str, List[str]]:
    """
    Parses /etc/shorewall/interfaces to map zones to physical/virtual interfaces.
    """
    print("--- DEBUG: Starting parse_shorewall_interfaces ---")
    interfaces_file = Path("/etc/shorewall/interfaces")
    if not interfaces_file.exists(): 
        print("DEBUG (shorewall.py): /etc/shorewall/interfaces not found!")
        return {}
        
    zone_map = {}
    try:
        with open(interfaces_file, 'r') as f:
            for i, line in enumerate(f.readlines()):
                line = line.strip()
                if not line or line.startswith('#'): continue
                parts = re.split(r'\s+', line)
                if len(parts) >= 2 and parts[0] != '-' and parts[1] != '-':
                    zone, interface = parts[0], parts[1]
                    print(f"  > Line {i+1}: Found zone '{zone}' -> interface '{interface}'")
                    zone_map.setdefault(zone, []).append(interface)
    except IOError as e:
        print(f"DEBUG: IOError reading interfaces file: {e}")
        return {}
    
    print(f"--- DEBUG: Finished parse_shorewall_interfaces, returning: {zone_map} ---")
    return zone_map


def generate_accounting_rules(config: Dict) -> str:
    """
    Generates /etc/shorewall/accounting rules with detailed debugging output.
    """
    header = [ "# This file is auto-generated by inetctl. Do not edit manually.", "# Defines zone-based accounting tables for the xt_ACCOUNT module." ]
    print("\n--- DEBUG: Starting generate_accounting_rules ---")
    
    try:
        vlan_subnets = get_vlan_subnets()
        zone_interfaces = parse_shorewall_interfaces()
        print(f"DEBUG: Found Netplan VLANs/Subnets: {vlan_subnets}")
        print(f"DEBUG: Found Shorewall Zones/Interfaces from parser: {zone_interfaces}")
        all_system_interfaces = list(set(item for sublist in zone_interfaces.values() for item in sublist))
        print(f"DEBUG: Flattened list of all system interfaces: {all_system_interfaces}")

    except Exception as e:
        print(f"DEBUG: CRITICAL ERROR during system config parsing: {e}")
        return "\n".join(header + [f"# ERROR: Could not parse network configuration: {e}"])
        
    rules = []
    for zone, interfaces in zone_interfaces.items():
        # Heuristic to match Shorewall zone (e.g., 'V15') to a netplan interface (e.g., 'vlan15')
        vlan_name_guess = zone.lower().replace('v','vlan')
        subnet = vlan_subnets.get(vlan_name_guess)
        
        print(f"\nProcessing Zone: '{zone}'")
        print(f"  > Guessed netplan name: '{vlan_name_guess}' -> Found Subnet: {subnet}")
        
        if not subnet:
            print("  > SKIPPING zone because no matching subnet was found in Netplan.")
            continue

        other_interfaces = set(all_system_interfaces) - set(interfaces)
        
        for if1, if2 in permutations(interfaces, 2):
            rules.append(f"ACCOUNT({zone},{subnet})\t-\t{if1}\t\t{if2}")
            
        for zone_if in interfaces:
            for other_if in other_interfaces:
                rules.append(f"ACCOUNT({zone},{subnet})\t-\t{zone_if}\t\t{other_if}")
                rules.append(f"ACCOUNT({zone},{subnet})\t-\t{other_if}\t\t{zone_if}")
            rules.append(f"ACCOUNT({zone},{subnet})\t-\t{zone_if}\t\t$FW")
            rules.append(f"ACCOUNT({zone},{subnet})\t-\t$FW\t\t{zone_if}")

    print(f"\nDEBUG: Total rules generated: {len(rules)}")
    print("--- DEBUG: Finished generate_accounting_rules ---")
    
    return "\n".join(header + ["#\n# ACTION\t\t\tSOURCE\t\tDEST"] + sorted(list(set(rules)))) + "\n"


def generate_mangle_rules(config: Dict) -> str:
    """Generates the content for /etc/shorewall/mangle (tcrules)."""
    gs = config.get("global_settings", {}); known_hosts = config.get("known_hosts", [])
    qos_policies = gs.get("qos_policies", {})
    header = ["# This file is auto-generated by inetctl. Do not edit manually.", "# Marks packets for Quality of Service (QoS).", "# ACTION\tSOURCE\t\tDEST"]
    rules = []
    
    if qos_policies:
        policy_to_mark = {name: details["fw_mark"] for name, details in qos_policies.items() if "fw_mark" in details}
        static_hosts = [h for h in known_hosts if h.get("ip_assignment", {}).get("type") == "static"]
        for host in static_hosts:
            policy, mark, ip = host.get("qos_policy"), policy_to_mark.get(host.get("qos_policy")), host.get("ip_assignment", {}).get("ip")
            if all([policy, mark, ip]): 
                rules.append(f"MARK({mark})\t\t{ip}\t\t0.0.0.0/0")
    
    return "\n".join(header + rules) + "\n"