from pathlib import Path
from typing import Dict, List

from inetctl.core.utils import get_active_leases

def apply_shorewall_config(file_path_str: str, new_content: str) -> bool:
    """
    Safely writes new content to a Shorewall configuration file.
    Only writes and returns True if the new content is different from the old.
    """
    file_path = Path(file_path_str)
    file_path.touch(mode=0o640, exist_ok=True) # Ensure file exists with correct permissions

    current_content = file_path.read_text()

    if current_content.strip() == new_content.strip():
        return False
    else:
        file_path.write_text(new_content)
        return True

def generate_accounting_rules(config: Dict) -> str:
    """Generates the content for /etc/shorewall/accounting."""
    gs = config.get("global_settings", {})
    leases_file = gs.get("dnsmasq_leases_file", "")
    active_leases = get_active_leases(leases_file)

    header = [
        "# This file is auto-generated by inetctl. Do not edit manually.",
        "# Defines chains for per-device bandwidth accounting.",
        "# SECTION ALL",
        "#"
    ]
    rules = []
    processed_macs = set()

    for device in active_leases:
        mac = device.get("mac")
        ip = device.get("ip")
        if not mac or not ip or mac in processed_macs:
            continue
            
        mac_sanitized = mac.replace(":", "")
        chain_name = f"acct_{mac_sanitized}"
        rules.append(f"{chain_name}:accounting_bytes\t-\t-\t{ip}\t-\t-")
        rules.append(f"{chain_name}:accounting_bytes\t-\t-\t-\t{ip}\t-")
        processed_macs.add(mac)

    if not rules:
        return "\n".join(header) + "\n# No active devices found for accounting.\n"

    return "\n".join(header + rules) + "\n"

def generate_mangle_rules(config: Dict) -> str:
    """Generates the content for /etc/shorewall/mangle (tcrules)."""
    gs = config.get("global_settings", {})
    known_hosts = config.get("known_hosts", [])
    qos_policies = gs.get("qos_policies", {})

    header = [
        "# This file is auto-generated by inetctl. Do not edit manually.",
        "# Marks packets for Quality of Service (QoS) based on host configuration.",
        "# SECTION ALL",
        "# ACTION        SOURCE          DEST",
    ]
    rules = []

    # Get a mapping from policy name to firewall mark
    policy_to_mark = {name: details["fw_mark"] for name, details in qos_policies.items()}
    
    # Static IPs get processed first
    static_hosts = [h for h in known_hosts if h.get("ip_assignment", {}).get("type") == "static"]

    for host in static_hosts:
        policy = host.get("qos_policy")
        mark = policy_to_mark.get(policy)
        ip = host.get("ip_assignment", {}).get("ip")
        
        if policy and mark and ip:
            # Mark packets originating from the host IP
            rules.append(f"MARK({mark})\t\t{ip}\t\t0.0.0.0/0\t\t-")

    # The CONNMARK rule saves the mark for the connection's lifetime
    footer = [
        "CONNMARK\t0.0.0.0/0\t0.0.0.0/0\t-",
    ]

    return "\n".join(header + rules + footer) + "\n"


def generate_policy_rules(config: Dict) -> str:
    """
    Generates the content for /etc/shorewall/policy.
    For now, this is mostly static but can be expanded.
    """
    header = [
        "# This file is auto-generated by inetctl. Do not edit manually.",
        "# Defines high-level firewall policies between zones.",
        "# SOURCE        DEST            POLICY          LOG_LEVEL       LIMIT",
        "#"
    ]

    # These rules are foundational and should generally be present.
    # The user should configure their main zone policies here (e.g., trusted -> net ACCEPT).
    base_rules = [
        "$FW\t\tnet\t\tACCEPT",
        "net\t\tall\t\tDROP\t\tinfo",
        "blocked\t\tall\t\tREJECT\t\tinfo", # This rule enforces the dynamic block zone
        "# THE FOLLOWING POLICY MUST BE LAST",
        "all\t\tall\t\tREJECT\t\tinfo"
    ]

    return "\n".join(header + base_rules) + "\n"