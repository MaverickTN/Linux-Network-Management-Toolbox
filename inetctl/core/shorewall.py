from pathlib import Path
from typing import Dict, List
import re

from inetctl.core.utils import get_active_leases

def apply_shorewall_config(file_path_str: str, new_content: str, managed_block_name: str = None) -> bool:
    """
    Safely writes new content to a Shorewall configuration file.

    If a `managed_block_name` is provided, this function will only replace content
    within the '# --- INETCTL MANAGED <name> START ---' and '# --- INETCTL MANAGED <name> END ---'
    block, preserving all other user-defined content.

    If the block does not exist, it will be appended to the end of the file.

    If no `managed_block_name` is provided, it will overwrite the whole file.
    """
    file_path = Path(file_path_str)
    if not file_path.parent.exists():
        print(f"ERROR: Cannot write to {file_path_str}, parent directory does not exist.")
        return False

    file_path.touch(mode=0o640, exist_ok=True) 
    current_content = file_path.read_text()
    
    # Logic for overwriting the entire file (legacy behavior for accounting, mangle)
    if not managed_block_name:
        if current_content.strip() == new_content.strip():
            return False
        else:
            file_path.write_text(new_content)
            return True

    # --- NEW SAFE LOGIC FOR MANAGED BLOCKS (e.g., policy file) ---
    start_marker = f"# --- INETCTL MANAGED {managed_block_name} START ---"
    end_marker = f"# --- INETCTL MANAGED {managed_block_name} END ---"
    
    # Ensure the managed content ends with a newline for clean insertion
    managed_content_with_markers = f"{start_marker}\n{new_content.strip()}\n{end_marker}\n"

    # Use regex to find and replace the existing block, or append if not found
    block_pattern = re.compile(f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL)
    
    if block_pattern.search(current_content):
        updated_content = block_pattern.sub(managed_content_with_markers, current_content)
    else:
        # If the block doesn't exist, append it cleanly to the end of the file
        updated_content = current_content.strip() + "\n\n" + managed_content_with_markers

    if current_content.strip() == updated_content.strip():
        return False
    else:
        file_path.write_text(updated_content)
        return True

def generate_accounting_rules(config: Dict) -> str:
    """Generates the content for /etc/shorewall/accounting."""
    gs = config.get("global_settings", {})
    leases_file = gs.get("dnsmasq_leases_file", "")
    active_leases = get_active_leases(leases_file) if leases_file else []
    header = [ "# This file is auto-generated by inetctl. Do not edit manually.", "# Defines chains for per-device bandwidth accounting.", "#", "# CHAIN\t\tACTION\tSOURCE\t\tDEST" ]
    rules = [f"{f'acct_{d[mac]}'.replace(':', '')}\t-\t-\t\t{d['ip']}" for d in active_leases]
    rules.extend([f"{f'acct_{d[mac]}'.replace(':', '')}\t-\t{d['ip']}\t\t-" for d in active_leases])
    return "\n".join(header + sorted(list(set(rules)))) + "\n"

def generate_mangle_rules(config: Dict) -> str:
    """Generates the content for /etc/shorewall/mangle (tcrules)."""
    gs = config.get("global_settings", {})
    known_hosts = config.get("known_hosts", [])
    qos_policies = gs.get("qos_policies", {})
    header = ["# This file is auto-generated by inetctl. Do not edit manually.", "# Marks packets for Quality of Service (QoS).", "# ACTION\tSOURCE\t\tDEST"]
    rules, policy_to_mark = [], {}
    if qos_policies:
        policy_to_mark = {name: details["fw_mark"] for name, details in qos_policies.items()}
        static_hosts = [h for h in known_hosts if h.get("ip_assignment", {}).get("type") == "static"]
        for host in static_hosts:
            policy, mark, ip = host.get("qos_policy"), policy_to_mark.get(host.get("qos_policy")), host.get("ip_assignment", {}).get("ip")
            if all([policy, mark, ip]): rules.append(f"MARK({mark})\t\t{ip}\t\t0.0.0.0/0")
    footer = [ "", "# Restore marks on established connections", "CONNMARK\t0.0.0.0/0\t0.0.0.0/0\t-" ]
    return "\n".join(header + rules + footer) + "\n"

def generate_policy_rules(config: Dict) -> str:
    """
    Generates the rules for the inetctl-managed block in /etc/shorewall/policy.
    This content will be safely inserted into the policy file.
    """
    # These are the only rules our application *needs* to enforce for its features.
    # The user is responsible for all other policies (e.g., lan->net ACCEPT).
    inetctl_rules = [
        "# These rules are required for inetctl block/allow features.",
        "# Do not edit content between the INETCTL markers.",
        "net\t\tall\t\tDROP\t\tinfo",
        "# The following rule must be last in this block, just before the 'all all' catch-all.",
        "all\t\tall\t\tREJECT\t\tinfo"
    ]
    return "\n".join(inetctl_rules)