from pathlib import Path
from typing import Dict, List
from itertools import permutations
import re

from lnmt.core.netplan import get_vlan_subnets, get_base_interface_subnet

def apply_shorewall_config(file_path_str: str, new_content: str, managed_block_name: str = None) -> bool:
    file_path = Path(file_path_str)
    if not file_path.parent.exists(): return False
    file_path.touch(mode=0o640, exist_ok=True); current_content = file_path.read_text()
    if not managed_block_name:
        if current_content.strip() == new_content.strip(): return False
        file_path.write_text(new_content); return True
    start_marker, end_marker = f"# --- lnmt MANAGED {managed_block_name} START ---", f"# --- lnmt MANAGED {managed_block_name} END ---"
    managed_content_with_markers = f"{start_marker}\n{new_content.strip()}\n{end_marker}\n"
    block_pattern = re.compile(f"{re.escape(start_marker)}.*?{re.escape(end_marker)}", re.DOTALL)
    if block_pattern.search(current_content): updated_content = block_pattern.sub(managed_content_with_markers, current_content)
    else: updated_content = current_content.strip() + "\n\n" + managed_content_with_markers
    if current_content.strip() == updated_content.strip(): return False
    file_path.write_text(updated_content); return True

def parse_shorewall_interfaces() -> Dict[str, List[str]]:
    interfaces_file = Path("/etc/shorewall/interfaces"); zone_map = {}
    if not interfaces_file.exists(): return {}
    try:
        with open(interfaces_file, 'r') as f:
            for line in f.readlines():
                line = line.strip()
                if not line or line.startswith('#') or line.startswith('?'): continue
                parts = re.split(r'\s+', line)
                if len(parts) >= 2 and parts[0] != '-' and parts[1] != '-': zone_map.setdefault(parts[0], []).append(parts[1])
    except IOError: return {}
    return zone_map

def generate_accounting_rules(config: Dict) -> str:
    header = [ "# This file is auto-generated by lnmt.", "# Defines zone-based accounting tables." ]
    try:
        vlan_subnets, zone_interfaces = get_vlan_subnets(), parse_shorewall_interfaces()
        lan_iface_name = config.get("global_settings", {}).get("lan_interface")
        if lan_iface_name and (base_lan_subnet := get_base_interface_subnet(lan_iface_name)):
            vlan_subnets[lan_iface_name] = base_lan_subnet
    except Exception as e: return f"\n".join(header + [f"# ERROR: Could not parse system config: {e}"])
    rules, ZONES_TO_IGNORE = [], {'net', 'local', 'docker', 'fw'}
    for zone, interfaces in zone_interfaces.items():
        if zone in ZONES_TO_IGNORE: continue
        iface_to_check, subnet = "", None
        # Heuristic matching zone name to interface name
        if zone.lower() == 'vlan1' and lan_iface_name: iface_to_check = lan_iface_name
        else:
            for iface in interfaces:
                if iface in vlan_subnets: iface_to_check = iface; break
        if iface_to_check: subnet = vlan_subnets.get(iface_to_check)
        if subnet: rules.append(f"ACCOUNT({zone},{subnet})\t-\t-")
    return "\n".join(header + ["#\n# ACTION(parameters)\tSOURCE\tDEST"] + sorted(list(set(rules)))) + "\n"

def generate_mangle_rules(config: Dict) -> str:
    gs, known_hosts = config.get("global_settings", {}), config.get("known_hosts", [])
    qos_policies = gs.get("qos_policies", {}); header = ["# This file is auto-generated by lnmt.", "# Marks packets for Quality of Service.", "# ACTION\tSOURCE\t\tDEST"]; rules = []
    if qos_policies:
        policy_to_mark = {name: d["fw_mark"] for name,d in qos_policies.items() if "fw_mark" in d}
        for h in (h for h in known_hosts if h.get("ip_assignment", {}).get("type") == "static"):
            if (p:=h.get("qos_policy")) and (m:=policy_to_mark.get(p)) and (ip:=h.get("ip_assignment", {}).get("ip")): rules.append(f"MARK({m})\t\t{ip}\t\t0.0.0.0/0")
    return "\n".join(header + rules) + "\n"